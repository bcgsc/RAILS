#!/usr/bin/env perl

#AUTHOR
#   Rene Warren
#   rwarren at bcgsc.ca
#
#
#   NAME
#   RAILS: Radial Assembly Improvement by Long Sequence Scaffolding 
#   Scaffolding and gap-closure using alignment of long sequences
#
#   SYNOPSIS
#
#   DOCUMENTATION
#      readme.md distributed with this software
#      We hope this code is useful to you -- Please send comments & suggestions to rwarren * bcgsc.ca
#      If you use RAILS, the RAILS code or ideas, please cite our work
#     
#
#   LICENSE
#      LINKS, RAILS and Cobbler Copyright (c) 2014-2019 Canada's Michael Smith Genome Science Centre.  All rights reserved.

use strict;
use Getopt::Std;
use Net::SMTP;
use vars qw($opt_f $opt_s $opt_d $opt_i $opt_e $opt_l $opt_a $opt_v $opt_b $opt_t $opt_p $opt_q $opt_g $opt_p);
getopts('f:s:d:e:l:a:v:b:t:p:i:q:g:p:');
my ($base_name,$anchor,$seqid,$insert_stdev,$min_links,$max_link_ratio,$grace,$verbose)=("",1000,0.9,1.0,1,0.99,1,0,);

my $version = "[v1.5.0]";
my $dev = "rwarren\@bcgsc.ca";
my $SAMPATH = "";
#-------------------------------------------------

if(! $opt_f || ! $opt_s || ! $opt_q || ! $opt_p){
   print "Usage: $0 $version\n";
   print "-f  Assembled Sequences to further scaffold (Multi-Fasta format, required)\n"; 
   print "-q  File of filenames containing long Sequences queried (Multi-Fasta format, required)\n";
   print "-s  File of filenames containing full path to BAM file(s) or simply type: "stream" for streaming the .sam output of minimap2 or favorite aligner\n";
   print "-p  Full path to samtools (known to work/tested with v1.8, required)\n";
   print "-d  Anchoring bases on contig edges (ie. minimum required alignment size on contigs, default -d $anchor, optional)\n";
   print "-i  Minimum sequence identity fraction (0 to 1), default -i $seqid, optional\n";
   print "-t  LIST of names/header, long sequences to avoid using for merging/gap-filling scaffolds (optional)\n"; 
   #print "-e  Error (%) allowed on -d distance   e.g. -e 0.1  == distance +/- 10% (default -e $insert_stdev, optional)\n";
   print "-l  Minimum number of links to compute scaffold (default -l $min_links, optional)\n";
   print "-a  Maximum link ratio between two best contig pairs *higher values lead to least accurate scaffolding* (default -a $max_link_ratio, optional)\n";
   print "-g  Grace length (bp), default -g $grace, optional\n";
   print "-b  Base name for your output files (optional)\n";
   print "-v  Runs in verbose mode (-v 1 = yes, default = no, optional)\n"; 
   die   "IMPORTANT: the order of files in -q and -s MUST match!\n";
}

my $file = $opt_f;
my $fof = $opt_s;
my $queryfof = $opt_q;
$anchor = $opt_d if($opt_d);
$seqid = $opt_i if($opt_i);
$verbose = $opt_v if($opt_v);
#DO NOT UNCOMMENT THE FOLLOWING LINES, ONLY DEFAULTS TO BE USED WITH RAILS
$min_links = $opt_l if($opt_l);
$max_link_ratio = $opt_a if($opt_a);
#$insert_stdev = $opt_e if($opt_e);
my $listfile = $opt_t if($opt_t);
$base_name = $opt_b if($opt_b);
$grace = $opt_g if($opt_g);
$SAMPATH = $opt_p if($opt_p);

my $assemblyruninfo="";


if(! -e $file){
   die "Invalid file: $file -- fatal\n";
}

if(! -e $SAMPATH){
   die "Invalid: $SAMPATH -- fatal\n";
}

### Naming output files
if ($base_name eq ""){

   $base_name = $file . ".scaff_s-" . $fof . "_q-" . $queryfof . "_d" . $anchor . "_i" . $seqid . "_e" . $insert_stdev . "_l" . $min_links . "_a" . $max_link_ratio . "_g" . $grace . "_t" . $listfile;

   my $pid_num = getpgrp(0);
   $base_name .= "_pid" . $pid_num;
}

my $log = $base_name . ".log";
my $scaffold = $base_name . ".scaffolds";
my $issues = $base_name . ".pairing_issues";
my $distribution = $base_name . ".pairing_distribution.csv";

open (LOG, ">$log") || die "Can't write to $log -- fatal\n";


#-------------------------------------------------

my $init_message = "\nRunning: $0 $version\n-f $file\n-q $queryfof\n-s $fof\n";

$init_message .= "-d $anchor\n-i $seqid\n-e $insert_stdev\n-l $min_links\n-a $max_link_ratio\n-g $grace\n-t $listfile\n";

print $init_message;
print LOG $init_message;
$assemblyruninfo=$init_message . "\n";

#-------------------------------------------------

my $date = `date`;
chomp($date);

my $reading_reads_message = "\n=>Reading bam: $date\n";
print $reading_reads_message;
print LOG $reading_reads_message;
$assemblyruninfo.=$reading_reads_message;
my $matepair;
my $tigpair;
my $initpos=0;
my $totalpairs=0;
my ($track_all,$tig_length,$tignames);

### READ Query read FOF
my @qryfilearray;
open(QRYFOF,$queryfof) || die "Can't open $queryfof for reading -- fatal.\n";
while(<QRYFOF>){
   chomp;
   push @qryfilearray, $_;   
}
close QRYFOF;


if(-f $fof){

   my $ctline=0;

   open(FOF,$fof) || die "Can't open $fof for reading -- fatal.\n";
   while(<FOF>){
      chomp;
      my $bamfile = $_;
      my $rh = &readSeqMemory($qryfilearray[$ctline]);### ONLY READ READ SEQUENCE IN MEMORY FOR THOSE MATCHING BAM (SAME ORDER NEEDED)
      print "Parsing alignment file $bamfile...\n";
      ($matepair,$track_all,$tigpair)=&readBam($matepair,$track_all,$tigpair,$bamfile,$anchor,$seqid,$listfile,$matepair,$initpos,$rh,$grace);
      print "done.\n";
      $ctline++;
   }
   close FOF;

}elsif($opt_s eq "stream"){### STREAMING SUPPORT 

   my $rh = &readSeqMemory($qryfilearray[0]);### ONLY SUPPORT ONE READ FILE
   print "Parsing alignment file...\n";
   ($matepair,$track_all,$tigpair)=&readSam($matepair,$track_all,$tigpair,$opt_s,$anchor,$seqid,$listfile,$matepair,$initpos,$rh,$grace);
   print "done.\n";

}



($tig_length,$tignames) = &readContigs($file);

open (SC, ">$scaffold") || die "\nCan't write to $scaffold -- fatal\n";
$date = `date`;
chomp($date);
my $sc_start_message = "\n=>Scaffolding initiated: $date\n";
print $sc_start_message;
print LOG $sc_start_message;
$assemblyruninfo.= $sc_start_message . "\n";

my $contigpairs  = &pairContigs($matepair,$track_all,$tig_length,$issues,$distribution,$totalpairs,$verbose);
&buildScaffolds($contigpairs,$tig_length,$verbose);
 
close SC;
$date = `date`;
chomp($date);

my $sc_end_message = "=>Scaffolding ended: $date\n";
print $sc_end_message;
print LOG $sc_end_message;
$assemblyruninfo.= $sc_end_message . "\n";
print "Scaffolds layout in: $scaffold\n";

$date = `date`;
chomp($date);

my $sc_fasta_message = "=>Making fasta file: $date\n";
print $sc_fasta_message;
print LOG $sc_fasta_message;
$assemblyruninfo.= $sc_fasta_message . "\n";

my $tighash = &readContigsMemory($file);
my ($scaffold_fasta,$gsl,$merges) = &buildScaffoldFasta($scaffold,$tighash,$tigpair);

$date = `date`;
chomp($date);

print "Scaffolds fasta in: $scaffold_fasta\n";

my ($avg,$sum,$max,$min) = &average($gsl);
my $sd = &stdev($gsl);
my $final_message = "--------------- $0 Summary ---------------\nNumber of merges induced : %i\nAverage closed gap length (bp) : %.2f\nClosed gap length st.dev +/- : %.2f\nTotal bases added : %i\nLargest gap resolved (bp) : %i\nShortest gap resolved (bp) : %i\n---------------------------------------------\n*0 bp gaps are not counted towards the average\n";
my @arrsg=@$gsl;
my $numgaps = $#arrsg+1;
printf $final_message, ($merges,$avg,$sd,$sum,$max,$min);
printf LOG $final_message, ($merges,$avg,$sd,$sum,$max,$min);

$assemblyruninfo .= "done: $date\n\n--------------- $0 Summary ---------------\nNumber of merges : $numgaps\nAverage closed gap length (bp) : $avg\nClosed gap length st.dev +/- : $sd\nTotal bases added : $sum\nLargest gap resolved (bp) : $max\nShortest gap resolved (bp) : $min\n---------------------------------------------\n*0 bp gaps are not counted towards the average\n";

close LOG;

exit;

###for dev. test purposes
eval{
   my $wdir = `pwd`;
   chomp($wdir);
   my $smtp = Net::SMTP->new('mailhost');
   $smtp->mail("RAILS\@bcgsc.ca");
   $smtp->to($dev);
   $smtp->data();
   $smtp->datasend("Subject: Your $0 run\n");
   $smtp->datasend("At: $wdir\n");
   $smtp->datasend($assemblyruninfo);
   $smtp->dataend();
   $smtp->quit;
};

exit;

#----------------
sub average{
        my $data = shift;
        if (not @$data) {
                die("Empty arrayn -- maybe the scaffold merging step did not necessitate gap filling. It is also possible that your version of samtools is not supported. This script was tested with samtools v1.8.");
        }
        my $total = 0;
        my $max = 0;
        my $min = 1000000;
        foreach (@$data) {
                $total += $_;
                $max = $_ if($_ > $max);
                $min = $_ if($_ < $min);
        }
        my $average = $total / @$data;
        return $average,$total,$max,$min;
}
#----------------
sub stdev{
        my $data = shift;
        if(@$data == 1){
                return 0;
        }
        my $average = &average($data);
        my $sqtotal = 0;
        foreach(@$data) {
                $sqtotal += ($average-$_) ** 2;
        }
        my $std = ($sqtotal / (@$data-1)) ** 0.5;
        return $std;
}

#----------------
sub readContigs{
   my $file = shift;

   my ($tig_length,$tignames);
   my $head ="";
   my $cttig=0;
   open(IN,$file) || die "Error reading $file -- fatal.\n";

   print "\nContigs processed:\n";
   while(<IN>){
      chomp;
      if(/^\>(\S+)/){
         $head=$1;
         $cttig++;
         $tignames->{$cttig}=$head;
         print "\r$cttig";
         $|++;
      }else{
         my $len = length($_);
         $tig_length->{$cttig} = $len;
      }
   }
   close IN;

   return $tig_length,$tignames;
}

#---------------
sub readSam{

   my ($matepair,$track_all,$tigpair,$bamfile,$anchor,$seqid,$listfile,$matepair,$initpos,$rh,$grace) = @_;

   my $mem;
   if(-f $listfile){ 
      open(IN,$listfile) || die "Can't read $listfile -- fatal.\n";
      while(<IN>){
         chomp;
         $mem->{$_}=1;
      }
      close IN;
   }
   my $bt;
#HS9_159:6:1308:13492:64472      272     scaffold43,6983,f43Z6983        6439    0       536M    *       0       0       *       *       NM:i:0  AS:i:536
#HS9_159:6:1308:13492:64472      0       scaffold30,32025,f30Z32025      25411   0       536M    *       0       0       GCTTATAAAAGAAGGTGCAATTGATCCTTGCCTTACGCCTACAAAGGAGGGTAGGTGCGATTGGTCCTTACATTCTTACGCCGCTTAGGAAGCTAGGCGAGATAGGATGGGTTCTAGAGCACCTAACTAGCTTTACACGCCGAATCCAGACCTGCCGGCTACCATCCGGATTCATACTAGATAACATAAAGGAGAGAACAACTGTTCAAAGAACAACTCGGAGAACATTTGTATCCGGTGGTTGGGGCATTGCGTGCTATACCAACTACCTCAGGTGCGCGAGGTCTCATTCCTTTTCCAAGCCCAATAAAGAAAAAATATCATTAGTGATGGTGAATCCCGTTTATATAAGTAAGTTGCATTCTTATCTAAGTAAGTGGGCTTTCCTAAGTCACTTATTGGGTGGGGGGCCCCTGTCGAGTGAGCCATCCTTCCTCACCCTCTCTTTTGTTGGGCGAGCCATCTTTCCTTTTATACGATTCGATCCAGTAGATAAGGAAGACCGACCGAGAACAACCAATGGCCTTCCCTGGGGG        *       NM:i:0  AS:i:536        XS:i:536
#HS9_159:6:1308:13492:64472      272     scaffold22,90777,f22Z90777      90233   0       536M    *       0       0       *       *       NM:i:0  AS:i:536
   my $t;
   my $ct=0;

   my %options = ();

   print join(
    "\t",
    'qname',
    'qstart',
    'qend',
    'qalen',
        'qlen',
    'rname',
    'rstart',
    'rend',
    'ralen',
        'rlen',
        'edit_dist',
   ) . "\n" if $options{header};


   my %rlength = ();

   while(<>){###will stream from STDIN

      chomp;
      $ct++;

      my @a=split(/\t/);
      my @b=split(/\,/,$a[2]);
      my @c=split(/\,/,$a[0]);


      if ($options{rlen} && /^\@SQ\s+SN:(\S+)\s+LN:(\S+)/) {
         $rlength{$1} = $2;
      }
      next unless @a >= 10;
      my $line = $_;
      my $qname = $a[0];
      my $rname = $a[2];
      my $rstart = $a[3];
      my $cigar = $a[5];
      my $qseq = $a[9];
      # Query
      my $qstart = 1;
      $_ = $cigar;
      s/^(\d+)[SH]/$qstart += $1/eg;
      my $qalen = 0;
      $_ = $cigar;
      s/(\d+)[M=XI]/$qalen += $1/eg;
      my $qend = $qstart + $qalen - 1;
      $_ = $cigar;
      my $end_clip_len = 0;
      s/(\d+)[SH]$/$end_clip_len += $1/eg;
      my $qlen = $c[1];

      # Reference
      my $ralen = 0;
      $_ = $cigar;
      s/(\d+)[M=XDN]/$ralen += $1/eg;
      my $rend = $rstart + $ralen - 1;
      my $rlen = $b[1];

      # Calculate edit distance including clipping
      my $edit_dist = '';
      if ($line =~ /NM:i:(\d+)/) {
         $edit_dist = $1;# + $qstart - 1 + $end_clip_len;
      }

      my $read = $a[0] . "-" . $ct;
      my $si=0;
      $si = ($qalen - $edit_dist) / $qalen if($qalen);


      if($si >= $seqid && $qalen >= $anchor && (( $rstart <= $grace &&  ($qlen-$qend)<= $grace) || ($qstart<=$grace && ($rlen-$rend)<=$grace )    )){     ### this indicates anchoring bases, within $anchor of edges


         my $start;
         my $end;
         ###Coordinates on the scaffolds
         if($rstart <= $grace &&  ($qlen-$qend)<= $grace){
            $start = $rend;
            $end = $rstart;
         }else{
            $start = $rstart;
            $end = $rend;
         }
         my $orient="";
         if($a[1]==272 || $a[1]==16 || $a[1]==2064){ ### matches on negative strand
            $orient="r";
            my $tmpstart = $qlen - $qend;
            my $tmpend = $qlen - $qstart;
            $qstart = $tmpstart;
            $qend = $tmpend;
         }else{
            $orient="f";
         }

         $t->{$a[0]}{$a[2]}{'order'}=$ct;
         $t->{$a[0]}{$a[2]}{'orient'}=$orient ;
         $t->{$a[0]}{$a[2]}{'real'}=$read;
         $t->{$a[0]}{$a[2]}{'length'}=$qlen;
         if($a[2]=~/\D+(\d+)\,(\d+)/){### scaffoldNUMBER,LENGTH eg. wga1,1301
            my ($numtig,$sz)=($1,$2);
            $track_all->{$read}{'tig'}=$numtig;
            $track_all->{$read}{'start'}=$start;
            $track_all->{$read}{'end'}=$end;
            $track_all->{$read}{'multiple'}=1;
            $track_all->{$read}{'sam'}=$line;
            $track_all->{$read}{'orient'}=$orient;
            $track_all->{$read}{'qalen'}=$qalen;### tracks anchor size
            $track_all->{$read}{'qstart'}=$qstart;
            $track_all->{$read}{'qend'}=$qend;
            $track_all->{$read}{'si'}=$si;      ### tracks sequence identity
         }
      }
   }
   close IN;###End SAM parse
   my ($occ,$same)=(0,0);###TRACK REDUNDANCY

   foreach my $rd(keys %$t){
      my $scafflist=$t->{$rd};
      my $num = keys(%$scafflist);

      #if($num==2){###maps on two different scaffolds only
         my @arr;
         my $prev="";
         my $current="";
         my $totalreadlength=0;
         my $counttig = 0;
         #foreach my $scaff(keys %$scafflist){
         GETCONTIG:
         foreach my $scaff(sort {$scafflist->{$a}{'order'}<=>$scafflist->{$b}{'order'}} keys %$scafflist){### best contig alignments listed first
            $counttig++;
            $current = $scafflist->{$scaff}{'real'};
            $prev = $current if($prev eq "");
            $totalreadlength = $scafflist->{$scaff}{'length'};
            last GETCONTIG if($counttig==2);
         }
 
         my ($one,$two)=($track_all->{$current}{'tig'},$track_all->{$prev}{'tig'});
         if($track_all->{$prev}{'tig'}<$track_all->{$current}{'tig'}){
           ($one,$two)=($track_all->{$prev}{'tig'},$track_all->{$current}{'tig'})
         }

         ### this will track the best anchoring long reads for the merge/gapfill
         my $m1 = $track_all->{$current}{'qalen'} * $track_all->{$current}{'si'};
         my $m2 = $track_all->{$prev}{'qalen'} * $track_all->{$prev}{'si'};
         my $matchbases = $m1 + $m2;

         if(! defined $mem->{$rd} && ($track_all->{$current}{'qstart'} > $track_all->{$prev}{'qend'} || $track_all->{$prev}{'qstart'} > $track_all->{$current}{'qend'}) && $rh->{$rd} ne ""){### WILL TRACK BEST ANCHORING BASES

           ### This is used to count #support linkages and -a
           $matepair->{$prev}{$current}{'is'} = $totalreadlength;# - ($track_all->{$prev}{'qalen'} + $track_all->{$current}{'qalen'} );
           $matepair->{$prev}{$current}{'bt'}=0;
            
           if($matchbases > $bt->{$one}{$two}{'bestmatch'}){###conditional to track best patch sequence only

            $bt->{$one}{$two}{'bestmatch'} = $matchbases; ### beenthere, bt, tracks that two contigs have been merged by a read (first one it saw here) .. to allow patch to match the chosen read support
            my $pos=0;
            $pos = $track_all->{$prev}{'qend'} if($track_all->{$current}{'qstart'} > $track_all->{$prev}{'qend'});
            $pos = $track_all->{$current}{'qend'} if($track_all->{$prev}{'qstart'} > $track_all->{$current}{'qend'});            
            my $gapseqlen = $totalreadlength - ($track_all->{$prev}{'qalen'} + $track_all->{$current}{'qalen'});
            print ">$rd   $pos @ $gapseqlen \n$rh->{$rd}\n\n" if($verbose);
            my $patch = substr($rh->{$rd},$pos,$gapseqlen-1);

            #$patch = &reverseComplement($patch) if($track_all->{$prev}{'orient'} eq "-" && $track_all->{$current}{'orient'} eq "-"  );

            print "GAP:$patch\n" if($verbose);

            ###JUST SOME TEST CODE
            if(defined $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}){### previous patch saved
               $occ++;
               $same++ if($patch eq $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'});
               #print "$prev ($track_all->{$prev}{'tig'})...$current ($track_all->{$current}{'tig'})\n$tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}\nNEW GAP:\n$patch\n";
               #if($patch ne $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}){print "NOT SAME\n\n";}else{print "SAME\n\n";}
            }

            ### EVEN THOUGH A COUNTER 'distr' TRACKS NUMBER OF SUPPORT FOR TIG A AND B, LAST COMBO OVERRIDES REST THIS COULD BE PROBLEMATIC WHEN MULTIPLE READS SUPPORT SAME CONTIGS, SEE NOTE ABOVE AND REASON TO LIMIT SUPPORT TO FIRST READ SEEN
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'distr'}++;
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}=$patch;
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'configuration'}=$track_all->{$prev}{'orient'} . $track_all->{$prev}{'tig'} . $track_all->{$current}{'orient'} . $track_all->{$current}{'tig'};
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'origin'}=$rd;

            print ">>>> $track_all->{$prev}{'tig'} $track_all->{$current}{'tig'} $patch\n" if($verbose);

            print "$track_all->{$prev}{'sam'}\n$track_all->{$current}{'sam'}\n   x====x ($totalreadlength)  ($track_all->{$prev}{'qstart'}-$track_all->{$prev}{'qend'}:$track_all->{$prev}{'qalen'} $track_all->{$prev}{'orient'}) AND ($track_all->{$current}{'qstart'}-$track_all->{$current}{'qend'}:$track_all->{$current}{'qalen'} $track_all->{$current}{'orient'})\n===x    x==== sc$track_all->{$prev}{'tig'} ($track_all->{$prev}{'start'}-$track_all->{$prev}{'end'}:$track_all->{$prev}{'qalen'} $track_all->{$prev}{'orient'}) AND sc$track_all->{$current}{'tig'} ($track_all->{$current}{'start'}-$track_all->{$current}{'end'}:$track_all->{$current}{'qalen'} $track_all->{$current}{'orient'}) \n\n" if($verbose);
          }###matchbase used to track best patch sequence
         }
      #}
   }

   print "\nRedundant same contig combo linking:$occ\nSame gap sequence fill:$same\n\n";
   return $matepair,$track_all,$tigpair;
}


#---------------
sub readBam{

   my ($matepair,$track_all,$tigpair,$bamfile,$anchor,$seqid,$listfile,$matepair,$initpos,$rh,$grace) = @_;

   my $mem;
   if(-f $listfile){ 
      open(IN,$listfile) || die "Can't read $listfile -- fatal.\n";
      while(<IN>){
         chomp;
         $mem->{$_}=1;
      }
      close IN;
   }
   my $bt;
#HS9_159:6:1308:13492:64472      272     scaffold43,6983,f43Z6983        6439    0       536M    *       0       0       *       *       NM:i:0  AS:i:536
#HS9_159:6:1308:13492:64472      0       scaffold30,32025,f30Z32025      25411   0       536M    *       0       0       GCTTATAAAAGAAGGTGCAATTGATCCTTGCCTTACGCCTACAAAGGAGGGTAGGTGCGATTGGTCCTTACATTCTTACGCCGCTTAGGAAGCTAGGCGAGATAGGATGGGTTCTAGAGCACCTAACTAGCTTTACACGCCGAATCCAGACCTGCCGGCTACCATCCGGATTCATACTAGATAACATAAAGGAGAGAACAACTGTTCAAAGAACAACTCGGAGAACATTTGTATCCGGTGGTTGGGGCATTGCGTGCTATACCAACTACCTCAGGTGCGCGAGGTCTCATTCCTTTTCCAAGCCCAATAAAGAAAAAATATCATTAGTGATGGTGAATCCCGTTTATATAAGTAAGTTGCATTCTTATCTAAGTAAGTGGGCTTTCCTAAGTCACTTATTGGGTGGGGGGCCCCTGTCGAGTGAGCCATCCTTCCTCACCCTCTCTTTTGTTGGGCGAGCCATCTTTCCTTTTATACGATTCGATCCAGTAGATAAGGAAGACCGACCGAGAACAACCAATGGCCTTCCCTGGGGG        *       NM:i:0  AS:i:536        XS:i:536
#HS9_159:6:1308:13492:64472      272     scaffold22,90777,f22Z90777      90233   0       536M    *       0       0       *       *       NM:i:0  AS:i:536
   my $t;
   my $ct=0;

   my %options = ();

   print join(
    "\t",
    'qname',
    'qstart',
    'qend',
    'qalen',
        'qlen',
    'rname',
    'rstart',
    'rend',
    'ralen',
        'rlen',
        'edit_dist',
   ) . "\n" if $options{header};


   my %rlength = ();

   my $ERRLOG = $bamfile.".bampreprocessor.err.log".$$.time();
   my $cmd = "$SAMPATH view $bamfile 2>$ERRLOG|";###read BAM
   open(IN,$cmd) || die "Error reading $bamfile -- fatal.\n";
   while(<IN>){

      chomp;
      $ct++;

      my @a=split(/\t/);
      my @b=split(/\,/,$a[2]);
      my @c=split(/\,/,$a[0]);


      if ($options{rlen} && /^\@SQ\s+SN:(\S+)\s+LN:(\S+)/) {
         $rlength{$1} = $2;
      }
      next unless @a >= 10;
      my $line = $_;
      my $qname = $a[0];
      my $rname = $a[2];
      my $rstart = $a[3];
      my $cigar = $a[5];
      my $qseq = $a[9];
      # Query
      my $qstart = 1;
      $_ = $cigar;
      s/^(\d+)[SH]/$qstart += $1/eg;
      my $qalen = 0;
      $_ = $cigar;
      s/(\d+)[M=XI]/$qalen += $1/eg;
      my $qend = $qstart + $qalen - 1;
      $_ = $cigar;
      my $end_clip_len = 0;
      s/(\d+)[SH]$/$end_clip_len += $1/eg;
      my $qlen = $c[1];

      # Reference
      my $ralen = 0;
      $_ = $cigar;
      s/(\d+)[M=XDN]/$ralen += $1/eg;
      my $rend = $rstart + $ralen - 1;
      my $rlen = $b[1];

      # Calculate edit distance including clipping
      my $edit_dist = '';
      if ($line =~ /NM:i:(\d+)/) {
         $edit_dist = $1;# + $qstart - 1 + $end_clip_len;
      }

      my $read = $a[0] . "-" . $ct;
      my $si=0;
      $si = ($qalen - $edit_dist) / $qalen if($qalen);


      if($si >= $seqid && $qalen >= $anchor && (( $rstart <= $grace &&  ($qlen-$qend)<= $grace) || ($qstart<=$grace && ($rlen-$rend)<=$grace )    )){     ### this indicates anchoring bases, within $anchor of edges


         my $start;
         my $end;
         ###Coordinates on the scaffolds
         if($rstart <= $grace &&  ($qlen-$qend)<= $grace){
            $start = $rend;
            $end = $rstart;
         }else{
            $start = $rstart;
            $end = $rend;
         }
         my $orient="";
         if($a[1]==272 || $a[1]==16 || $a[1]==2064){ ### matches on negative strand
            $orient="r";
            my $tmpstart = $qlen - $qend;
            my $tmpend = $qlen - $qstart;
            $qstart = $tmpstart;
            $qend = $tmpend;
         }else{
            $orient="f";
         }

         $t->{$a[0]}{$a[2]}{'order'}=$ct;
         $t->{$a[0]}{$a[2]}{'orient'}=$orient ;
         $t->{$a[0]}{$a[2]}{'real'}=$read;
         $t->{$a[0]}{$a[2]}{'length'}=$qlen;
         if($a[2]=~/\D+(\d+)\,(\d+)/){### scaffoldNUMBER,LENGTH eg. wga1,1301
            my ($numtig,$sz)=($1,$2);
            $track_all->{$read}{'tig'}=$numtig;
            $track_all->{$read}{'start'}=$start;
            $track_all->{$read}{'end'}=$end;
            $track_all->{$read}{'multiple'}=1;
            $track_all->{$read}{'sam'}=$line;
            $track_all->{$read}{'orient'}=$orient;
            $track_all->{$read}{'qalen'}=$qalen;### tracks anchor size
            $track_all->{$read}{'qstart'}=$qstart;
            $track_all->{$read}{'qend'}=$qend;
            $track_all->{$read}{'si'}=$si;      ### tracks sequence identity
         }
      }
   }
   close IN;###End SAM parse
   my ($occ,$same)=(0,0);###TRACK REDUNDANCY

   foreach my $rd(keys %$t){
      my $scafflist=$t->{$rd};
      my $num = keys(%$scafflist);

      #if($num==2){###maps on two different scaffolds only
         my @arr;
         my $prev="";
         my $current="";
         my $totalreadlength=0;
         my $counttig = 0;
         #foreach my $scaff(keys %$scafflist){
         GETCONTIG:
         foreach my $scaff(sort {$scafflist->{$a}{'order'}<=>$scafflist->{$b}{'order'}} keys %$scafflist){### best contig alignments listed first
            $counttig++;
            $current = $scafflist->{$scaff}{'real'};
            $prev = $current if($prev eq "");
            $totalreadlength = $scafflist->{$scaff}{'length'};
            last GETCONTIG if($counttig==2);
         }
 
         my ($one,$two)=($track_all->{$current}{'tig'},$track_all->{$prev}{'tig'});
         if($track_all->{$prev}{'tig'}<$track_all->{$current}{'tig'}){
           ($one,$two)=($track_all->{$prev}{'tig'},$track_all->{$current}{'tig'})
         }

         ### this will track the best anchoring long reads for the merge/gapfill
         my $m1 = $track_all->{$current}{'qalen'} * $track_all->{$current}{'si'};
         my $m2 = $track_all->{$prev}{'qalen'} * $track_all->{$prev}{'si'};
         my $matchbases = $m1 + $m2;

         if(! defined $mem->{$rd} && ($track_all->{$current}{'qstart'} > $track_all->{$prev}{'qend'} || $track_all->{$prev}{'qstart'} > $track_all->{$current}{'qend'}) && $rh->{$rd} ne ""){### WILL TRACK BEST ANCHORING BASES

           ### This is used to count #support linkages and -a
           $matepair->{$prev}{$current}{'is'} = $totalreadlength;# - ($track_all->{$prev}{'qalen'} + $track_all->{$current}{'qalen'} );
           $matepair->{$prev}{$current}{'bt'}=0;
            
           if($matchbases > $bt->{$one}{$two}{'bestmatch'}){###conditional to track best patch sequence only

            $bt->{$one}{$two}{'bestmatch'} = $matchbases; ### beenthere, bt, tracks that two contigs have been merged by a read (first one it saw here) .. to allow patch to match the chosen read support
            my $pos=0;
            $pos = $track_all->{$prev}{'qend'} if($track_all->{$current}{'qstart'} > $track_all->{$prev}{'qend'});
            $pos = $track_all->{$current}{'qend'} if($track_all->{$prev}{'qstart'} > $track_all->{$current}{'qend'});            
            my $gapseqlen = $totalreadlength - ($track_all->{$prev}{'qalen'} + $track_all->{$current}{'qalen'});
            print ">$rd   $pos @ $gapseqlen \n$rh->{$rd}\n\n" if($verbose);
            my $patch = substr($rh->{$rd},$pos,$gapseqlen-1);

            #$patch = &reverseComplement($patch) if($track_all->{$prev}{'orient'} eq "-" && $track_all->{$current}{'orient'} eq "-"  );

            print "GAP:$patch\n" if($verbose);

            ###JUST SOME TEST CODE
            if(defined $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}){### previous patch saved
               $occ++;
               $same++ if($patch eq $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'});
               #print "$prev ($track_all->{$prev}{'tig'})...$current ($track_all->{$current}{'tig'})\n$tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}\nNEW GAP:\n$patch\n";
               #if($patch ne $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}){print "NOT SAME\n\n";}else{print "SAME\n\n";}
            }

            ### EVEN THOUGH A COUNTER 'distr' TRACKS NUMBER OF SUPPORT FOR TIG A AND B, LAST COMBO OVERRIDES REST THIS COULD BE PROBLEMATIC WHEN MULTIPLE READS SUPPORT SAME CONTIGS, SEE NOTE ABOVE AND REASON TO LIMIT SUPPORT TO FIRST READ SEEN
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'distr'}++;
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'seq'}=$patch;
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'configuration'}=$track_all->{$prev}{'orient'} . $track_all->{$prev}{'tig'} . $track_all->{$current}{'orient'} . $track_all->{$current}{'tig'};
            $tigpair->{$track_all->{$prev}{'tig'}}{$track_all->{$current}{'tig'}}{'origin'}=$rd;

            print ">>>> $track_all->{$prev}{'tig'} $track_all->{$current}{'tig'} $patch\n" if($verbose);

            print "$track_all->{$prev}{'sam'}\n$track_all->{$current}{'sam'}\n   x====x ($totalreadlength)  ($track_all->{$prev}{'qstart'}-$track_all->{$prev}{'qend'}:$track_all->{$prev}{'qalen'} $track_all->{$prev}{'orient'}) AND ($track_all->{$current}{'qstart'}-$track_all->{$current}{'qend'}:$track_all->{$current}{'qalen'} $track_all->{$current}{'orient'})\n===x    x==== sc$track_all->{$prev}{'tig'} ($track_all->{$prev}{'start'}-$track_all->{$prev}{'end'}:$track_all->{$prev}{'qalen'} $track_all->{$prev}{'orient'}) AND sc$track_all->{$current}{'tig'} ($track_all->{$current}{'start'}-$track_all->{$current}{'end'}:$track_all->{$current}{'qalen'} $track_all->{$current}{'orient'}) \n\n" if($verbose);
          }###matchbase used to track best patch sequence
         }
      #}
   }

   print "\nRedundant same contig combo linking:$occ\nSame gap sequence fill:$same\n\n";
   return $matepair,$track_all,$tigpair;
}

#-----------------------
sub reverseComplement{
   $_ = shift;
   $_ = uc();
   tr/ATGCYRKMBDHV/TACGRYMKVHDB/;
   return (reverse());
}

#------------------------------------
#Order and orient contigs into scaffolds
sub buildScaffolds{

   my ($pair, $tig_length, $contig_size_cutoff, $verbose) = @_;

   my $seen_it;
   my $sc_ct = 0;
 
   #print SC "Scaffold Number,Scaffold Size (only contig lengths considered),Scaffold Chain: e.g. _f127z7068k12a0.58m42_r3090z62k7r0.14m76_  means: contig127(+ strand=f), size 7068 (z) has 12 links (k), link ratio of 0.58 (a) and with a mean gap/overlap of 42nt (m)  with reverse (r) of contig3090 (size 62) on the right.\n";

   SEED:
   foreach my $tig (sort {$tig_length->{$b}<=>$tig_length->{$a}} keys %$tig_length){

      my $ftig = "f" . $tig;
      my $rtig = "r" . $tig;

      if(! defined $seen_it->{$tig}){##should prevent re-using a contig as seed if it's already been incorporated into a scaffold

         $sc_ct++;

         my $chainleft = "";
          
         my $ori_chainright = $ftig . "Z" . $tig_length->{$tig};
         my $chainright = $ori_chainright;
         my $total = $tig_length->{$tig};

         ($total, $chainright, $seen_it) = &computeLayout("R", $chainright, $ftig, $pair, $tig_length, $total, $seen_it, $tig);
         ($total, $chainleft, $seen_it) = &computeLayout("L", $chainleft, $rtig, $pair, $tig_length, $total, $seen_it, $tig);

         $seen_it->{$tig}++;

         delete $pair->{$ftig};
         delete $pair->{$rtig};
         delete $tig_length->{$tig};

         my $scaffold = $chainleft . $chainright;
         print SC "scaffold" . $sc_ct . ",$total,$scaffold\n" if($total >= $contig_size_cutoff);
      }
   }
}

#------------------------------------
# links contigs together into a chain - must satisfy user-defined criterions (-k -a)
sub computeLayout{

   my ($ext, $chain, $tig, $pair, $tig_length, $total, $seen_it, $orig_tig_number) = @_;

   my $orig_tig = $tig;
   my $extension = 1;

   EXTENSION:
   while($extension){

      my $tnum = $1 if($tig=~/[fr](\d+)/);
      my $tnumf = "f" . $tnum;
      my $tnumr = "r" . $tnum;

      if(! defined $seen_it->{$tnum}){

         $seen_it->{$tnum}++ if($tnumf ne $orig_tig);

         print "Attempt to extend $tig\n" if ($verbose);      
         my $list = $pair->{$tig};
         my ($match1,$link1,$gaps1,$match2,$link2,$gaps2,$cntloop)=("",0,0,"",0,0,0);

         LINK:
         foreach my $match (sort {$list->{$b}{'links'}<=>$list->{$a}{'links'}} keys %$list){### sort by most supported links

            if($cntloop){
               ($match2,$link2,$gaps2) = ($match,$list->{$match}{'links'},$list->{$match}{'gaps'});
               print "$tig links second best $match2 (links:$link2 total sz:$gaps2)\n" if ($verbose);
               last LINK;
            }else{
               ($match1,$link1,$gaps1) = ($match,$list->{$match}{'links'},$list->{$match}{'gaps'});
               print "$tig links best $match1 (links:$link1 total sz:$gaps1)\n" if ($verbose);
            }
            $cntloop++;
         }

         ###ratio
         my $ratio = 0.00;
         $ratio = $link2 / $link1 if ($link1);        ## relative ratio of the two most abundant contig pairs
         if ($ratio =~ /(\d+\.\d{2})/){$ratio = $1;}
         ###mean
         my $mean = 0;
         $mean = int($gaps1 / $link1) if ($link1);

         my $tempnum = $1 if($match1 =~ /[fr](\d+)/);

         #### Assessment
         if(defined $seen_it->{$tempnum} || $link1 < $min_links || $ratio > $max_link_ratio || $tempnum == $orig_tig_number){
            $extension = 0;
            print "defined seen_it->{ $tempnum } || $link1 < $min_links || $ratio > $max_link_ratio\n L1:$link1 L2:$link2  M1:$match1 M2:$match2 G1:$gaps1 G2:$gaps2 "  if ($verbose);

            last EXTENSION;
         }{### pass filter.. does this contig 
            print "$ext extension.  mean: $mean links:$link1 linkratio:$ratio\n" if ($verbose);

            if($ext eq "R"){
               $chain .= "k" . $link1 . "a" . $ratio . "m" . $mean . "_" . $match1 . "z" . $tig_length->{$tempnum};
            }else{
               my $temp_match = "";
               if($match1 =~ /^r(\d+)/){$temp_match = "f" . $1;}else{$temp_match = "r". $1;}            
               $chain = $temp_match . "z" . $tig_length->{$tempnum} . "k" . $link1 . "a" . $ratio . "m" . $mean . "_" . $chain;
            }   
            $total += $tig_length->{$tempnum};

            print "NEXT TIG TO LOOK AT= $match1\n" if ($verbose);
            $tig = $match1;
            $extension = 1; 
          
            print "Will flag $tnum as seen  (only if $tnumf != $orig_tig)." if ($verbose);
   
            if($tnumf ne $orig_tig){
               delete $pair->{$tnumf};
               delete $pair->{$tnumr};
               delete $tig_length->{$tnum};
            }else{
               delete $pair->{$tnumf};
            }
         }
      }else{
         print "NO MORE MATCH FOR $tig in hash: pair>>\n" if ($verbose);
         $extension = 0;
         last EXTENSION;
      }
   }### pair is defined
   return $total, $chain, $seen_it;
}

#------------------------------------
sub getDistance{

   my ($insert_size, $length_i, $start_i, $start_j) = @_;

   # L  ------  --------- R
   # i    ->        <-    j
   #      ....  ......    insert_span
   #      ============    insert_size

   my $insert_span = ($length_i - $start_i) + $start_j;
   my $gap_or_overlap = $insert_size - $insert_span;

   return $gap_or_overlap;
}

#-----------------
#build contig pairs based on template information  -  must satisfy user-defined criterions (-d -e)
sub pairContigs{

   my ($matepair,$track,$tig_length,$issues,$distribution,$totalpairs,$verbose) = @_;
   my ($ct_illogical, $ct_ok_contig, $ct_ok_pairs, $ct_problem_pairs, $ct_iz_issues, $ct_single, $ct_both)= (0,0,0,0,0,0,0);
   my $ct_illogical_hash;
   my $ct_ok_contig_hash;
   my $ct_ok_pairs_hash;
   my $ct_problem_pairs_hash;
   my $ct_iz_issues_hash;
   my $ct_single_hash;
   my $ct_both_hash;
   #$verbose=1;# XX for testing purposes
   my ($pair,$err,$track_insert);

   print "Pairing contigs...\n" if ($verbose);

   open(PET, ">$issues") || die "Can't open $issues for writing -- fatal\n";

   foreach my $read_a (keys %$matepair){ 
      my $mateslist = $matepair->{$read_a};

      foreach my $read_b (keys %$mateslist){

          if($matepair->{$read_a}{$read_b}{'bt'}==0 && $track->{$read_a}{'multiple'}==1 && $track->{$read_b}{'multiple'}==1){ ###This has little if no effect, but negative for some odd reason

            ##below indicates this specific pair has been seen
            $matepair->{$read_a}{$read_b}{'bt'}=1;

            my $insert_size = $mateslist->{$read_b}{'is'};
            my $min_allowed = -1 * ($insert_stdev * $insert_size);
            my ($low_iz, $up_iz) = ($insert_size + $min_allowed, $insert_size - $min_allowed);
            #print "MIN ALLOWED: $min_allowed\n";
            print "Pair read1=$read_a read2=$read_b\n" if ($verbose);

            if(defined $track->{$read_a}{'tig'} && defined $track->{$read_b}{'tig'}){### both pairs assembled

               $ct_both++;
               $ct_both_hash->{$insert_size}++;

               my $tig_a = $track->{$read_a}{'tig'};
               my $tig_b = $track->{$read_b}{'tig'};

               my $ftig_a = "f" . $tig_a;
               my $ftig_b = "f" . $tig_b;

               my $rtig_a = "r" . $tig_a;
               my $rtig_b = "r" . $tig_b;

               my $A_length = $tig_length->{$tig_a};
               my $A_start = $track->{$read_a}{'start'};
               my $A_end = $track->{$read_a}{'end'};
 
               my $B_length = $tig_length->{$tig_b};
               my $B_start = $track->{$read_b}{'start'} ;
               my $B_end = $track->{$read_b}{'end'};

               if ($tig_a != $tig_b){####paired reads located on <> contigs

                  ####Determine most likely possibility
                  if ($track->{$read_a}{'start'} < $track->{$read_a}{'end'}){

                     if ($track->{$read_b}{'end'} < $track->{$read_b}{'start'}){####-> <- :::  A-> <-B  /  rB -> <- rA
                         my $d = &getDistance($insert_size, $A_length, $A_start, $B_start);
                         print "A-> <-B  WITH $tig_a -> <- $tig_b GAP $d A=$A_length ($A_start-$A_end) B=$B_length ($B_start-$B_end) Alen, Astart,Bstart\n" if($verbose);
                         if($d >= $min_allowed){
                            $pair->{$ftig_a}{$ftig_b}{'links'}++;
                            $pair->{$ftig_a}{$ftig_b}{'gaps'} += $d;                  
                            $pair->{$rtig_b}{$rtig_a}{'links'}++;
                            $pair->{$rtig_b}{$rtig_a}{'gaps'} += $d;
                            $ct_ok_pairs++;
                            $ct_ok_pairs_hash->{$insert_size}++;
                            #print "$ftig_a ($read_a) ...$ftig_b ($read_b)\n";
                         }else{
                            my $err_pair = $ftig_a . "-". $ftig_b;
                            $err->{$err_pair}{'links'}++;
                            $err->{$err_pair}{'gaps'} += $d;
                            $ct_problem_pairs++;
                            $ct_problem_pairs_hash->{$insert_size}++;
                            print PET "Pairs unsatisfied in distance within a contig pair.  A-> <-B  WITH tig#$tig_a -> $d <- tig#$tig_b, A=$A_length nt (start:$A_start, end:$A_end) B=$B_length nt (start:$B_start, end:$B_end) CALCULATED DISTANCE APART: $d < $min_allowed\n";
                         }
                      }else{#### -> -> ::: A-> <-rB  / B-> <-rA 
                         my $rB_start = $B_length - $B_start;
                         my $d = &getDistance($insert_size, $A_length, $A_start, $rB_start);
                         print "A-> <-rB  WITH $tig_a -> <- r.$tig_b GAP $d A=$A_length ($A_start-$A_end) B=$B_length ($B_start-$B_end) Alen,Astart,rBstart\n" if($verbose);
                         if($d >= $min_allowed){
                            $pair->{$ftig_a}{$rtig_b}{'links'}++;
                            $pair->{$ftig_a}{$rtig_b}{'gaps'} += $d;
                            $pair->{$ftig_b}{$rtig_a}{'links'}++;
                            $pair->{$ftig_b}{$rtig_a}{'gaps'} += $d;
                            $ct_ok_pairs++;
                            $ct_ok_pairs_hash->{$insert_size}++;
                            #print "$ftig_a ($read_a) ...$rtig_b ($read_b)\n";
                         }else{
                            my $err_pair = $ftig_a . "-". $rtig_b;
                            $err->{$err_pair}{'links'}++;
                            $err->{$err_pair}{'gaps'} += $d;
                            $ct_problem_pairs++;
                            $ct_problem_pairs_hash->{$insert_size}++;
                            print PET "Pairs unsatisfied in distance within a contig pair.  A-> <-rB  WITH tig#$tig_a -> $d <- tig#r.$tig_b, A=$A_length  nt (start:$A_start, end:$A_end) B=$B_length nt (start:$B_start, end:$B_end) CALCULATED DISTANCE APART: $d < $min_allowed\n";
                         }
                      }
                  }else{

                     if ($track->{$read_b}{'end'} > $track->{$read_b}{'start'}){####<-  -> ::: B-> <-A / rA -> <- rB
                        my $d = &getDistance($insert_size, $B_length, $B_start, $A_start);
                        print "B-> <-A  WITH $tig_b -> <- $tig_a GAP $d A=$A_length ($A_start-$A_end) B=$B_length ($B_start-$B_end) Blen,Bstart,Astart\n" if($verbose);
                        if($d >= $min_allowed){
                           $pair->{$ftig_b}{$ftig_a}{'links'}++;
                           $pair->{$ftig_b}{$ftig_a}{'gaps'} += $d;
                           $pair->{$rtig_a}{$rtig_b}{'links'}++;
                           $pair->{$rtig_a}{$rtig_b}{'gaps'} += $d;
                           $ct_ok_pairs++;
                           $ct_ok_pairs_hash->{$insert_size}++;
                           #print "$ftig_a ($read_a) ...$ftig_b ($read_b)\n";
                        }else{
                           my $err_pair = $ftig_b . "-". $ftig_a;
                           $err->{$err_pair}{'links'}++;
                           $err->{$err_pair}{'gaps'} += $d;
                           $ct_problem_pairs++;
                           $ct_problem_pairs_hash->{$insert_size}++;
                           print PET "Pairs unsatisfied in distance within a contig pair.  B-> <-A  WITH tig#$tig_b -> $d <- tig#$tig_a, B=$B_length nt (start:$B_start, end:$B_end) A=$A_length nt (start:$A_start, end:$A_end) CALCULATED DISTANCE APART: $d < $min_allowed\n";
                        }
                     }else{                          ####<- <-  :::  rB-> <-A / rA-> <-B
                        my $rB_start = $B_length - $B_start;
                        my $d = &getDistance($insert_size, $B_length, $rB_start, $A_start);
                        print "rB-> <-A WITH r.$tig_b -> <- $tig_a GAP $d A=$A_length ($A_start-$A_end) B=$B_length ($B_start-$B_end) Blen,rBstart,Astart\n" if($verbose);
                        if($d >= $min_allowed){
                           $pair->{$rtig_b}{$ftig_a}{'links'}++;
                           $pair->{$rtig_b}{$ftig_a}{'gaps'} += $d;
                           $pair->{$rtig_a}{$ftig_b}{'links'}++;
                           $pair->{$rtig_a}{$ftig_b}{'gaps'} += $d;
                           $ct_ok_pairs++;
                           $ct_ok_pairs_hash->{$insert_size}++;
                           #print "$ftig_a ($read_a) ...$rtig_b ($read_b)\n";
                        }else{
                           my $err_pair = $rtig_b . "-". $ftig_a;
                           $err->{$err_pair}{'links'}++;
                           $err->{$err_pair}{'gaps'} += $d;
                           $ct_problem_pairs++;
                           $ct_problem_pairs_hash->{$insert_size}++;
                           print PET "Pairs unsatisfied in distance within a contig pair.  rB-> <-A WITH tig#r.$tig_b -> $d <- tig#$tig_a, B=$B_length nt (start:$B_start, end:$B_end) A=$A_length nt (start:$A_start, end:$A_end) CALCULATED DISTANCE APART: $d < $min_allowed\n";
                        }
                     }
                  }
               }else{###Clone, paired reads located on the same contig -- could be used to investigate misassemblies
           
                  print "Pair ($read_a and $read_b) located on same contig $tig_a ($A_length nt)\n" if ($verbose);
                  my $pet_size = 0;

                  if ($A_start > $B_start && ($B_start < $B_end) && ($A_start > $A_end)){    # B --> <-- A
                     $pet_size = $A_start - $B_start;
                     $track_insert->{$pet_size}++;
                     if($pet_size >= $low_iz && $pet_size <= $up_iz){
                        $ct_ok_contig++;
                        $ct_ok_contig_hash->{$insert_size}++;
                     }else{
                        print PET "Pairs unsatisfied in distance within a contig.  Pair ($read_a - $read_b) on contig $tig_a ($A_length nt) Astart:$A_start Aend:$A_end Bstart:$B_start Bend:$B_end CALCULATED DISTANCE APART: $pet_size\n";
                        $ct_iz_issues++;
                        $ct_iz_issues_hash->{$insert_size}++;
                     }
                  }elsif($B_start > $A_start && ($B_start > $B_end) && ($A_start < $A_end)){ # A --> <-- B
                     $pet_size = $B_start - $A_start;
                     $track_insert->{$pet_size}++;
                     if($pet_size >= $low_iz && $pet_size <= $up_iz){
                        $ct_ok_contig++;
                        $ct_ok_contig_hash->{$insert_size}++;
                     }else{
                        print PET "Pairs unsatisfied in distance within a contig.  Pair ($read_a - $read_b) on contig $tig_a ($A_length nt) Astart:$A_start Aend:$A_end Bstart:$B_start Bend:$B_end CALCULATED DISTANCE APART: $pet_size\n";
                        $ct_iz_issues++;
                        $ct_iz_issues_hash->{$insert_size}++;
                     }
                  }else{
                     $ct_illogical++;
                     $ct_illogical_hash->{$insert_size}++;
                     print PET "Pairs unsatisfied in pairing logic within a contig.  Pair ($read_a - $read_b) on contig $tig_a ($A_length nt) Astart:$A_start Aend:$A_end Bstart:$B_start Bend:$B_end\n";
                  }
               }
            }else{###both pairs assembled
               $ct_single++;
               $ct_single_hash->{$insert_size}++;
            }
         }#if unseen
      }#pairing read b
   }#read a

   ### summary of contig pair issues
   print PET "------------- Putative issues with contig pairing - Summary  ----------------\n";
   foreach my $err_pair (sort {$err->{$b}{'links'}<=>$err->{$a}{'links'}} keys %$err){
      my $mean_iz = 0;
      $mean_iz = $err->{$err_pair}{'gaps'} / $err->{$err_pair}{'links'} if ($err->{$err_pair}{'links'});
      print PET "Pair $err_pair has $err->{$err_pair}{'links'} links and mean distance = $mean_iz\n";
   }
   close PET;
 
   my $satisfied = $ct_ok_pairs + $ct_ok_contig;
   my $unsatisfied = $ct_problem_pairs + $ct_iz_issues + $ct_illogical;
   my $ct_both_reads = $ct_both * 2;

   print LOG "\n===========PAIRED K-MER STATS===========\n";
   print LOG "Total number of pairs extracted from -s $fof: $totalpairs\n";
   print LOG "At least one sequence/pair missing from contigs: $ct_single\n";
   print LOG "Assembled pairs: $ct_both ($ct_both_reads sequences)\n";
   print LOG "\tSatisfied in distance/logic within contigs (i.e. -> <-, distance on target: $ct_ok_contig\n";
   print LOG "\tUnsatisfied in distance within contigs (i.e. distance out-of-bounds): $ct_iz_issues\n";
   print LOG "\tUnsatisfied pairing logic within contigs (i.e. illogical pairing ->->, <-<- or <-->): $ct_illogical\n";
   print LOG "\t---\n";
   print LOG "\tSatisfied in distance/logic within a given contig pair (pre-scaffold): $ct_ok_pairs\n";
   print LOG "\tUnsatisfied in distance within a given contig pair (i.e. calculated distances out-of-bounds): $ct_problem_pairs\n";
   print LOG "\t---\n";
   print LOG "Total satisfied: $satisfied\tunsatisfied: $unsatisfied\n\nBreakdown by insert sizes:\n";

   #foreach my $izopt(sort {$a<=>$b} keys %$ct_both_hash){
   #   print LOG "--------Reads with $izopt bp inserts--------\n";
   #   my $maopt = -1 * ($insert_stdev * $izopt);
   #   my ($low_izopt, $up_izopt) = ($izopt + $maopt, $izopt - $maopt);
   #   print LOG "MIN:$low_izopt MAX:$up_izopt as defined by $izopt * $insert_stdev\n";
   #   print LOG "At least one sequence/pair missing: $ct_single_hash->{$izopt}\n";
   #   print LOG "Assembled pairs: $ct_both_hash->{$izopt}\n";
   #   print LOG "\tSatisfied in distance/logic within contigs (i.e. -> <-, distance on target: $ct_ok_contig_hash->{$izopt}\n";
   #   print LOG "\tUnsatisfied in distance within contigs (i.e. distance out-of-bounds): $ct_iz_issues_hash->{$izopt}\n";
   #   print LOG "\tUnsatisfied pairing logic within contigs (i.e. illogical pairing ->->, <-<- or <-->): $ct_illogical_hash->{$izopt}\n";
   #   print LOG "\t---\n";
   #   print LOG "\tSatisfied in distance/logic within a given contig pair (pre-scaffold): $ct_ok_pairs_hash->{$izopt}\n";
   #   print LOG "\tUnsatisfied in distance within a given contig pair (i.e. calculated distances out-of-bounds): $ct_problem_pairs_hash->{$izopt}\n";
   #}
   print LOG "============================================\n";

   open (CSV, ">$distribution") || die "Can't open $distribution for writing -- fatal";

   foreach my $is (sort {$a<=>$b} keys %$track_insert){
      print CSV "$is,$track_insert->{$is}\n";
   }

   close CSV;
   return $pair;
}

#-------------------
sub readSeqMemory{

   my $file = shift;

   my $fh;
   my $prev="NA";
   my $seq="";
   open(FA,$file) || die "Cannot open $file for reading -- fatal.\n";
   while(<FA>){
      chomp;
      if (/\>(\S+)/){
         my $head=$1;
         #$seq =~ s/[BDEFHIJKLMOPQRSUVWXYZ]/N/g;
         if($prev ne $head && $prev ne "NA"){
             $fh->{$prev} = $seq;
         }
         $prev = $head;
         $seq='';
      }elsif(/^(\S+)$/){
         $seq .= uc($1);
      }
   }
   $fh->{$prev} = $seq;

   close FA;

   return $fh;
}

#-------------------
sub readContigsMemory{
 
   my $file = shift;

   my $fh;
   my $prev="NA";
   my $seq="";
   my $cttig=0;
   open(FA,$file) || die "Cannot open $file for reading -- fatal.\n";
   while(<FA>){
      chomp;
      if (/\>(\S+)/){
         $cttig++;
         my $head=$cttig;
	 #RLW2016 $seq =~ s/[BDEFHIJKLMOPQRSUVWXYZ]/N/g;
         if($prev ne $head && $prev ne "NA" && $seq ne ""){
             $fh->{$prev} = $seq;
         }
         $prev = $head;
         $seq='';
      }elsif(/^(\S+)$/){
	      #RLW2016 $seq .= uc($1);
	 $seq .= $1;
      }
   }
   $fh->{$prev} = $seq;
   close FA;

   return $fh;
}

#-------------------
sub buildScaffoldFasta{

   my ($dotscaffold,$fh,$tigpair) = @_;

   open(IN,$dotscaffold) || die "Cannot open $dotscaffold for reading -- fatal.\n";

   my $scaffold_fasta = $dotscaffold . ".fa";
   my $gaplist = $dotscaffold . "_GAPseqList.txt";

   open(OUT,">$scaffold_fasta") || die "can't write to $scaffold_fasta -- fatal\n";
   open(LIST,">$gaplist") || die "can't write to $gaplist -- fatal\n";

   my $tot=0;
   my $sct=0;
   my @gsl;
   my $merges=0;

   while(<IN>){
      chomp;   
      my $sc="";
      my @a = split(/\,/);
      my @tig;
   
      if($a[2]=~/\_/){
         @tig = split(/\_/,$a[2]);
      }else{
         push @tig, $a[2];
      }

      $sct++;
      my $tigsum=0;

      my $oldhead = $_;
      my $scaffseq = "";

      my $ct=0;
      $merges += $#tig;
      foreach my $t (@tig){
         
    
         if($t=~/([fr])(\d+)z(\d+)(\S+)?/i){
            my $orient = $1;
            my $tnum=$2;
            my $head = $orient . $tnum;
            my $search = $tnum;
            my $other = $4;
            $tot+= $3;
            $tigsum +=$3;
   
            my $gap = "NA"; 
            my $gapseq = "";
            $gap = $1 if($other=~/m(\-?\d+)/);
 
            my $seq = $fh->{$search};
            $seq = &reverseComplement($seq) if($orient eq "r");

            my $f = $tig[$ct+1];###lookup ahead 
            if($f=~/([fr])(\d+)z(\d+)(\S+)?/i){
               my $forient = $1;
               my $ftnum=$2;

               ### if rc a forward alignment then must rc a patch
               if(defined $tigpair->{$tnum}{$ftnum}{'seq'}){
                 print LIST "$tigpair->{$tnum}{$ftnum}{'origin'}\n";
                 $gapseq = lc($tigpair->{$tnum}{$ftnum}{'seq'});
		 
                 my $configuration = $tigpair->{$tnum}{$ftnum}{'configuration'};
                 my ($str1,$tig1,$str2,$tig2) = ($1,$2,$3,$4) if($tigpair->{$tnum}{$ftnum}{'configuration'}=~/([rf])(\d+)([rf])(\d+)/);
                 if($tig1==$tnum && $tig2==$ftnum){
                    if($str1 ne $orient){
                       $gapseq = &reverseComplement($tigpair->{$tnum}{$ftnum}{'seq'});
                    }
                 }
               }elsif(defined $tigpair->{$ftnum}{$tnum}{'seq'}){
                 print LIST "$tigpair->{$ftnum}{$tnum}{'origin'}\n";
                 $gapseq = lc($tigpair->{$ftnum}{$tnum}{'seq'});
                 my $configuration = $tigpair->{$ftnum}{$tnum}{'configuration'};
                 my ($str1,$tig1,$str2,$tig2) = ($1,$2,$3,$4) if($tigpair->{$ftnum}{$tnum}{'configuration'}=~/([rf])(\d+)([rf])(\d+)/);
                 if($tig1==$ftnum && $tig2==$tnum){
                    if($str1 ne $forient){
                       $gapseq = &reverseComplement($tigpair->{$ftnum}{$tnum}{'seq'});
                    }
                 }
               }

               #if(defined $tigpair->{$tnum}{$ftnum}{'seq'}){
               #  $gapseq = lc($tigpair->{$tnum}{$ftnum}{'seq'}); 
               #}elsif(defined $tigpair->{$ftnum}{$tnum}{'seq'}){
               #  $gapseq = lc($tigpair->{$ftnum}{$tnum}{'seq'});
               #}else{
               #   $gapseq = "N" x ($gap-1) if($gap > 0);
               #   $gapseq = "n" if($gap ne "NA" && $gap <= 0 );
               #}
            }
            my $gl = length($gapseq);
            push @gsl,$gl if($gl);
            $seq .= $gapseq;
            $scaffseq .= $seq;    
         }#tig regex
         $ct++; 
      }#each tig
      my $newlength = length($scaffseq);
      my $head = ">$a[0] $newlength $oldhead";
      print OUT "$head\n$scaffseq\n";
   }

   close IN;
   close OUT;
   close LIST;
   return $scaffold_fasta,\@gsl,$merges;
}

## We hope this code is useful to you -- Please send comments & suggestions to rwarren at bcgsc.ca
